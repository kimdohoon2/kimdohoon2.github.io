---
layout: single
title: "개인 프로젝트 회고 : 무한스크롤과 페이지네이션 구현 과정"
categories: 개인 프로젝트 회고
tag: [개인 프로젝트, 무한스크롤, 페이지네이션, React-query, 성능최적화]
toc: true
author_profile: false
# sidebar:
#     nav: "counts"
# search: true
---

### 🛠️ 프로젝트 소개

이전 포스트 「[개인 프로젝트 회고 : 무한스크롤 vs 페이지네이션](https://kimdohoon2.github.io/%EA%B0%9C%EC%9D%B8/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/%ED%9A%8C%EA%B3%A0/%EA%B0%9C%EC%9D%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0-%EB%AC%B4%ED%95%9C%EC%8A%A4%ED%81%AC%EB%A1%A4-vs-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98/)」에서 무한스크롤과 페이지네이션의 개념과 어떠한 상황에 따라 적용하는지 대해 알아보았습니다.

이번 포스트에서는 내 개인 프로젝트에서 이 두 가지 방식을 어떻게 구현했는지 기술적인 부분을 중심으로 살펴보겠습니다.

대한민국 구석구석 클론 프로젝트는 여행 정보를 제공하는 웹 서비스로, 지역별 여행지, 맛집, 숙소 정보 등을 제공한다.<br>
**검색 결과 페이지**에는 페이지네이션을, **지역 정보 더보기 페이지**에는 무한스크롤을 적용했다.

### 🔍 검색 결과 페이지 - 페이지네이션 구현

#### 구현 목표와 주요 기능

- 카테고리별로 8개 항목만 초기 로드하여 로딩 시간 단축
- "더보기" 클릭 시 해당 카테고리의 추가 데이터만 로드
- 검색 결과에서 사용자 입력 키워드 하이라이트 처리
- 최근 검색어 및 추천 검색어 기능 제공

<video width="100%" controls>
  <source src="https://raw.githubusercontent.com/kimdohoon2/kimdohoon2.github.io/refs/heads/master/_video/%EA%B2%80%EC%83%89%EA%B8%B0%EB%8A%A51.mp4" type="video/mp4">
  브라우저가 video 태그를 지원하지 않습니다.
</video>

위 영상에서 볼 수 있듯이, 검색 결과는 카테고리별로 구분되며 초기에는 각 카테고리마다 8개의 항목만 로드됩니다. 이렇게 함으로써 초기 로딩 속도를 크게 향상시킬 수 있었습니다.

#### ✨ React Query를 적용하며 고민한 캐시 전략

검색 기능을 구현하면서 React Query의 useQuery를 활용해 데이터를 불러왔습니다.
아래는 제가 만든 커스텀 훅입니다.

```tsx
import { useQuery } from "@tanstack/react-query";
import { getSearchApi } from "@/app/api/getSearchApi";
import { SearchApiResponse } from "@/app/types/ItemType";

export function useSearchData(
  keyword: string,
  numOfRows: number,
  contentTypeId: string | null
) {
  return useQuery<SearchApiResponse[], Error>({
    queryKey: ["searchData", keyword, numOfRows, contentTypeId], // 캐싱 키
    queryFn: () => getSearchApi(keyword, numOfRows, contentTypeId),
    staleTime: 1000 * 60 * 15, // 15분 동안 데이터를 "신선"하게 유지
    gcTime: 1000 * 60 * 30, // 30분 동안 캐시 유지
    retry: 1, // 오류 시 1번만 재시도
    enabled: !!keyword, // 키워드가 있을 때만 쿼리 활성화
  });
}
```

이 훅을 사용하면 다음과 같은 이점이 있습니다.

- `staleTime`을 15분으로 설정해 같은 검색어를 반복 입력해도 API를 다시 호출하지 않음
- `gcTime`을 30분으로 설정해 캐시 유지 시간 최대화
- `retry`를 1로 설정해 오류 시 1번만 재시도
- `enabled` 옵션으로 키워드가 있을 때만 쿼리 실행

#### staleTime과 gcTime에 시간 설정에 대한 고민

검색어 기반 쿼리는 같은 키워드를 반복적으로 입력할 가능성이 높기 때문에,
불필요한 API 호출을 줄이기 위해 staleTime을 15분으로 설정했습니다.

- `staleTime`이 15분이면, 같은 쿼리 키워드로 검색했을 때 15분 동안은 캐시된 데이터를 사용하게 됩니다.
- 사용자 입장에서도 15분 이내의 결과는 크게 변하지 않는다고 판단해서, 충분한 값이라고 생각했습니다.
- 또한, `gcTime`은 30분으로 설정해 사용하지 않는 데이터도 메모리에서 오래 유지되도록 했습니다.
- 이유는 검색 결과는 한 번 보고 끝나는 것이 아니라, 다시 돌아와서 살펴보는 경우도 많기 때문입니다.

이 처럼 `React Query`의 캐시 전략은 UX와 성능 사이에서 균형을 잡는 게 핵심이었습니다.
처음엔 `staleTime`을 너무 짧게 줘서 API 요청이 너무 자주 발생했고,
반대로 너무 길게 잡으면 최신 검색 결과가 반영되지 않아 사용자 혼란이 생기기도 했습니다.

#### 🎯 최근 검색어 및 추천 검색어 기능

<video width="100%" controls>
  <source src="https://raw.githubusercontent.com/kimdohoon2/kimdohoon2.github.io/refs/heads/master/_video/%EA%B2%80%EC%83%89%EA%B8%B0%EB%8A%A52.mp4" type="video/mp4">
  브라우저가 video 태그를 지원하지 않습니다.
</video>

위 영상에서 최근 검색어 및 추천 검색어 기능을 볼 수 있습니다. 이 최근 검색어 기능은 다음과 같이 구현했습니다:

1-1. 상태 관리 및 초기화

```tsx
const MAX_RECENT_SEARCHES = 5;

export function useSearchLogic() {
  const [recentSearches, setRecentSearches] = useState<string[]>([]);

```

- MAX_RECENT_SEARCHES 상수는 저장할 최근 검색어의 최대 개수를 5개로 제한합니다.
- recentSearches 상태는 최근 검색어 목록을 배열로 관리합니다.

1-2. 로컬 스토리지에서 최근 검색어 불러오기

```tsx
useEffect(() => {
  const storedSearches = localStorage.getItem("recentSearches");
  if (storedSearches) {
    setRecentSearches(JSON.parse(storedSearches));
  }
}, []);
```

- 컴포넌트가 마운트될 때 localStorage에서 저장된 최근 검색어를 불러옵니다.
- JSON 파싱을 통해 문자열을 배열로 변환합니다.

1-3. 최근 검색어 저장 기능

```tsx
const saveRecentSearches = (searches: string[]) => {
  localStorage.setItem("recentSearches", JSON.stringify(searches));
  setRecentSearches(searches);
};

const addRecentSearch = (search: string) => {
  if (!search.trim() || search.length > 100) return;
  const updatedSearches = [
    search,
    ...recentSearches.filter((s) => s !== search),
  ].slice(0, MAX_RECENT_SEARCHES);
  saveRecentSearches(updatedSearches);
};
```

- saveRecentSearches 함수는 검색어 배열을 JSON 문자열로 변환하여 로컬 스토리지에 저장합니다.
- addRecentSearch 함수는 새로운 검색어를 추가하는 핵심 로직입니다.
- 빈 문자열이거나 100자를 초과하는 검색어는 추가하지 않습니다.
- 기존에 같은 검색어가 있으면 제거하고 새 검색어를 배열 맨 앞에 추가합니다.
- slice(0, MAX_RECENT_SEARCHES)를 통해 최대 5개만 유지합니다.

#### 📱 최근 검색어 저장 기능 요약

- 로컬 스토리지를 사용하여 검색 기록 유지
- 최대 5개 항목으로 제한
- 중복 검색어 처리: 같은 검색어는 최상단으로 이동
- 개별 삭제 및 전체 삭제 기능 제공

### 🔄 지역 더보기 페이지 - 무한스크롤 구현

#### 구현 목표와 주요 기능

- 스크롤 이벤트를 감지하여 추가 데이터 자동 로드
- React Query로 데이터 캐싱하여 불필요한 API 호출 최소화
- 한 번에 데이터를 8개씩 가져오고 최대 표시 항목은 24개로 제한

<video width="100%" controls>
  <source src="https://raw.githubusercontent.com/kimdohoon2/kimdohoon2.github.io/refs/heads/master/_video/무한스크롤2.mp4" type="video/mp4">
  브라우저가 video 태그를 지원하지 않습니다.
</video>

위 영상에서 볼 수 있듯이, 스크롤을 내리면 자동으로 다음 데이터가 로드됩니다. 이때 개발자 도구의 Network 탭을 보면 스크롤이 특정 지점에 도달했을 때만 API를 호출하여 불필요한 네트워크 요청을 최소화했습니다.

#### 🔍 react-intersection-observer로 스크롤 감지

```tsx
// react-intersection-observer 설정
const { ref, inView } = useInView({
  threshold: 0.5, // 요소가 50% 뷰포트에 들어왔을 때 트리거
});

// debounce로 API 호출 최적화
const fetchMoreData = useMemo(
  () =>
    debounce(() => {
      if (
        inView &&
        hasNextPage &&
        moreData.pages.flat().length < MAX_ITEMS &&
        !isFetchingRef.current
      ) {
        isFetchingRef.current = true; // 호출 중 상태 설정
        fetchNextPage().finally(() => {
          isFetchingRef.current = false; // 호출 완료 후 상태 해제
        });
      }
    }, 300), // 300ms 디바운스
  [inView, hasNextPage, fetchNextPage, moreData]
);

// 스크롤 감지 시 다음 페이지 데이터 로드
useEffect(() => {
  if (inView) {
    fetchMoreData();
  }
  return () => {
    fetchMoreData.cancel();
  };
}, [inView, fetchMoreData]);
```

이 구현의 특징

- `threshold: 0.5`로 요소가 화면의 50% 이상 보일 때만 로드
- `debounce`로 스크롤 이벤트 최적화
- `isFetchingRef`로 중복 API 호출 방지
- 최대 24개 항목만 로드하여 메모리 사용량 제한

#### threshold 고민

무한스크롤에서 react-intersection-observer를 활용해 다음 페이지를 로드하는 방식으로 구현했습니다. 이때 관찰 요소가 화면에 얼마나 보여야 콜백이 실행될지 결정하는 threshold 값에 대해 고민이 있었습니다.

처음에는 **threshold: 1**을 고려했습니다.

- 하지만 이 경우, 요소가 화면에 100% 보여야 다음 페이지를 불러오기 때문에 사용자가 스크롤을 완전히 끝까지 내려야만 동작해 UX가 답답하다는 문제가 있었습니다.

반대로 **threshold: 0.2**는

- 요소가 조금만 보여도 트리거되기 때문에 빠르게 로딩되긴 하지만, 불필요한 API 호출이 일어날 수 있는 위험이 있었습니다. 특히 느린 네트워크 환경에서는 중복 호출이나 과도한 로딩이 문제가 될 수 있다고 판단했습니다.

고민 끝에 0.5로 설정했습니다.

- 사용자가 스크롤을 어느 정도 내리면 부드럽게 다음 콘텐츠가 로드되고, 너무 빠르거나 너무 늦지 않게 UX와 성능의 균형을 맞출 수 있었습니다.

이처럼 threshold 값 하나도 사용자 경험과 성능에 영향을 주기 때문에 수치에 대한 실험과 테스트가 필요했습니다. 단순히 작동만 되는 것이 아닌 "언제 어떻게 작동할 것인가"에 대한 고민이 중요하다는 걸 느꼈습니다.

#### ✨ useInfiniteQuery로 효율적인 데이터 로딩

무한스크롤을 구현하기 위해 React Query의 `useInfiniteQuery`를 활용했습니다:

```tsx
// useTourDataInfinites.ts (핵심 구현)
const useTourDataInfinites = (
  selectedArea: string,
  numOfRows: number,
  category: string,
  initialData?: AreaItem[]
) => {
  return useInfiniteQuery<AreaItem[], Error>({
    queryKey: ["tourList", selectedArea, category],
    queryFn: ({ pageParam = 1 }) =>
      getTourListApi(selectedArea, numOfRows, pageParam as number, category),
    initialPageParam: 1,
    // 다음 페이지가 있는지 확인
    getNextPageParam: (lastPage, allPages) => {
      return lastPage.length < numOfRows ? undefined : allPages.length + 1;
    },
    // 필요시 초기 데이터 제공
    initialData: initialData
      ? {
          pages: [initialData],
          pageParams: [1],
        }
      : undefined,
    staleTime: 1000 * 60 * 15, // 15분
    gcTime: 1000 * 60 * 30, // 30분
  });
};
```

- `getNextPageParam`을 통해 다음 페이지 여부 판단
- 받아온 데이터가 `numOfRows`보다 적으면 더 이상 데이터가 없다고 판단
- 캐싱으로 페이지를 이동했다 돌아와도 API를 다시 호출하지 않음

<video width="100%" controls>
  <source src="https://raw.githubusercontent.com/kimdohoon2/kimdohoon2.github.io/refs/heads/master/_video/무한스크롤1.mp4" type="video/mp4">
  브라우저가 video 태그를 지원하지 않습니다.
</video>

위 영상에서 확인할 수 있듯이, 페이지를 떠났다가 다시 돌아와도 캐시된 데이터를 활용하여 추가 API 호출 없이 이전 상태를 유지합니다.

### 🔧 사용자 경험 개선과 성능 최적화 전략과 결과

#### 초기 페이지 로딩 속도 개선

- **초기 데이터 제한**: 각 카테고리별로 8개 항목만 로드하여 초기 로딩 속도 개선
- **지연 로딩**: 사용자가 필요로 할 때만 추가 데이터 로드
- **이미지 최적화**: next/image 컴포넌트로 이미지 최적화

#### API 호출 최적화

- **캐싱 전략**: staleTime, gcTime 설정으로 불필요한 API 호출 80% 감소
- **debounce** 적용: 스크롤 이벤트에 300ms debounce 적용하여 과도한 API 호출 방지

#### 사용자 경험 개선

- **스켈레톤 UI**: 데이터 로딩 중 스켈레톤 UI로 사용자 경험 향상
- **무한스크롤**: 스크롤을 내리면 자동으로 다음 페이지를 로드하여 사용자 편의성 향상
- **로컬스토리지**: 최근 검색어를 로컬스토리지에 저장하여 더 빠른 검색 결과 제공
- **최대 항목 수 제한**: 메모리 사용량 최적화 및 브라우저 성능 유지
- **키워드 하이라이트**: 검색 결과에서 입력 키워드를 시각적으로 강조

#### Lighthouse 결과

![image](https://raw.githubusercontent.com/kimdohoon2/kimdohoon2.github.io/refs/heads/master/_images/%EA%B2%B0%EA%B3%BC.PNG)

### 🎯 배운 점

이번 프로젝트를 통해 사용자 경험과 성능 최적화의 균형을 맞추는 법을 배웠다.

1. **사용자 중심 설계**

   - 단순 기능 구현이 아닌 사용자가 정보를 어떻게 소비하는지 고려한 설계가 중요
   - 기술적 효율성과 사용자 편의성 사이의 균형 유지

2. **성능 최적화**

   - 초기 로딩 속도, API 호출 최소화, 메모리 사용량 등 다양한 측면 고려
   - React Query의 캐싱 기능이 프론트엔드 성능 향상에 큰 도움

3. **기술적 선택**

   - 상황에 맞는 적절한 UI 패턴 선택(페이지네이션 vs 무한스크롤)
   - 라이브러리(React Query, Intersection Observer)를 활용한 효율적 구현

앞으로도 단순한 기능 구현이 아니라, 사용자 중심의 개발을 고민하며 성장하는 개발자가 되고 싶다.
