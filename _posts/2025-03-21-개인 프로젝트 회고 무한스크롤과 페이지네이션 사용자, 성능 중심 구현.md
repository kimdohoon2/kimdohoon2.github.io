---
layout: single
title: "개인 프로젝트 회고 : 무한스크롤과 페이지네이션 구현 과정"
categories: 개인 프로젝트 회고
tag: [개인 프로젝트, 무한스크롤, 페이지네이션, React-query, 성능최적화]
toc: true
author_profile: false
# sidebar:
#     nav: "counts"
# search: true
---

### 🛠️ 프로젝트 소개

이전 포스트 「[개인 프로젝트 회고 : 무한스크롤 vs 페이지네이션](/개인%20프로젝트%20회고/무한스크롤vs페이지네이션!/)」에서 무한스크롤과 페이지네이션의 개념과 각각이 적합한 상황에 대해 알아보았다.

이번 포스트에서는 내 개인 프로젝트에서 이 두 가지 방식을 어떻게 구현했는지 기술적인 부분을 중심으로 살펴보겠다.

내 프로젝트는 여행 정보를 제공하는 웹 서비스로, 지역별 여행지, 맛집, 숙소 정보 등을 제공한다.<br>
**검색 결과 페이지**에는 페이지네이션을, **지역 정보 더보기 페이지**에는 무한스크롤을 적용했다.

### 🔍 검색 결과 페이지 - 페이지네이션 구현

#### 구현 목표와 주요 기능

- 카테고리별로 8개 항목만 초기 로드하여 로딩 시간 단축
- "더보기" 클릭 시 해당 카테고리의 추가 데이터만 로드
- 검색 결과에서 사용자 입력 키워드 하이라이트 처리
- 최근 검색어 및 추천 검색어 기능 제공

<video width="100%" controls>
  <source src="https://raw.githubusercontent.com/kimdohoon2/kimdohoon2.github.io/refs/heads/master/_video/%EA%B2%80%EC%83%89%EA%B8%B0%EB%8A%A51.mp4" type="video/mp4">
  브라우저가 video 태그를 지원하지 않습니다.
</video>

위 영상에서 볼 수 있듯이, 검색 결과는 카테고리별로 구분되며 초기에는 각 카테고리마다 8개의 항목만 로드됩니다. 이렇게 함으로써 초기 로딩 속도를 크게 향상시킬 수 있었습니다.

#### ✨ React Query로 데이터 관리하기

React Query를 활용하여 API 호출을 관리하고 데이터를 캐싱했습니다. 아래는 검색 데이터를 가져오는 커스텀 훅의 핵심 부분입니다:

```tsx
import { useQuery } from "@tanstack/react-query";
import { getSearchApi } from "@/app/api/getSearchApi";
import { SearchApiResponse } from "@/app/types/ItemType";

export function useSearchData(
  keyword: string,
  numOfRows: number,
  contentTypeId: string | null
) {
  return useQuery<SearchApiResponse[], Error>({
    queryKey: ["searchData", keyword, numOfRows, contentTypeId], // 캐싱 키
    queryFn: () => getSearchApi(keyword, numOfRows, contentTypeId),
    staleTime: 1000 * 60 * 15, // 15분 동안 데이터를 "신선"하게 유지
    gcTime: 1000 * 60 * 30, // 30분 동안 캐시 유지
    retry: 1, // 오류 시 1번만 재시도
    enabled: !!keyword, // 키워드가 있을 때만 쿼리 활성화
  });
}
```

이 훅을 사용하면 다음과 같은 이점이 있습니다:

- `staleTime`을 15분으로 설정해 같은 검색어를 반복 입력해도 API를 다시 호출하지 않음
- `gcTime`을 30분으로 설정해 캐시 유지 시간 최대화
- `retry`를 1로 설정해 오류 시 1번만 재시도
- `enabled` 옵션으로 키워드가 있을 때만 쿼리 실행

#### 🎯 최근 검색어 및 추천 검색어 기능

<video width="100%" controls>
  <source src="https://raw.githubusercontent.com/kimdohoon2/kimdohoon2.github.io/refs/heads/master/_video/%EA%B2%80%EC%83%89%EA%B8%B0%EB%8A%A52.mp4" type="video/mp4">
  브라우저가 video 태그를 지원하지 않습니다.
</video>

위 영상에서 최근 검색어 및 추천 검색어 기능을 볼 수 있습니다. 이 기능은 다음과 같이 구현했습니다:

1-1. 상태 관리 및 초기화

```tsx
const MAX_RECENT_SEARCHES = 5;

export function useSearchLogic() {
  const [recentSearches, setRecentSearches] = useState<string[]>([]);

```

- MAX_RECENT_SEARCHES 상수는 저장할 최근 검색어의 최대 개수를 5개로 제한합니다.
- recentSearches 상태는 최근 검색어 목록을 배열로 관리합니다.

1-2. 로컬 스토리지에서 최근 검색어 불러오기

```tsx
useEffect(() => {
  const storedSearches = localStorage.getItem("recentSearches");
  if (storedSearches) {
    setRecentSearches(JSON.parse(storedSearches));
  }
}, []);
```

- 컴포넌트가 마운트될 때 localStorage에서 저장된 최근 검색어를 불러옵니다.
- JSON 파싱을 통해 문자열을 배열로 변환합니다.

1-3. 최근 검색어 저장 기능

```tsx
const saveRecentSearches = (searches: string[]) => {
  localStorage.setItem("recentSearches", JSON.stringify(searches));
  setRecentSearches(searches);
};

const addRecentSearch = (search: string) => {
  if (!search.trim() || search.length > 100) return;
  const updatedSearches = [
    search,
    ...recentSearches.filter((s) => s !== search),
  ].slice(0, MAX_RECENT_SEARCHES);
  saveRecentSearches(updatedSearches);
};
```

- saveRecentSearches 함수는 검색어 배열을 JSON 문자열로 변환하여 로컬 스토리지에 저장합니다.
- addRecentSearch 함수는 새로운 검색어를 추가하는 핵심 로직입니다.
- 빈 문자열이거나 100자를 초과하는 검색어는 추가하지 않습니다.
- 기존에 같은 검색어가 있으면 제거하고 새 검색어를 배열 맨 앞에 추가합니다.
- slice(0, MAX_RECENT_SEARCHES)를 통해 최대 5개만 유지합니다.

#### 📱 사용자 경험 개선 - 최근 검색어 저장 기능 요약

- 로컬 스토리지를 사용하여 검색 기록 유지
- 최대 5개 항목으로 제한
- 중복 검색어 처리: 같은 검색어는 최상단으로 이동
- 개별 삭제 및 전체 삭제 기능 제공

### 🔄 지역 더보기 페이지 - 무한스크롤 구현

#### 구현 목표와 주요 기능

- 스크롤 이벤트를 감지하여 추가 데이터 자동 로드
- React Query로 데이터 캐싱하여 불필요한 API 호출 최소화
- 한 번에 데이터를 8개씩 가져오고 최대 표시 항목은 24개로 제한

<video width="100%" controls>
  <source src="https://raw.githubusercontent.com/kimdohoon2/kimdohoon2.github.io/refs/heads/master/_video/무한스크롤2.mp4" type="video/mp4">
  브라우저가 video 태그를 지원하지 않습니다.
</video>

위 영상에서 볼 수 있듯이, 스크롤을 내리면 자동으로 다음 데이터가 로드됩니다. 이때 개발자 도구의 Network 탭을 보면 스크롤이 특정 지점에 도달했을 때만 API를 호출하여 불필요한 네트워크 요청을 최소화했습니다.

#### ✨ useInfiniteQuery로 효율적인 데이터 로딩

무한스크롤을 구현하기 위해 React Query의 `useInfiniteQuery`를 활용했습니다:

```tsx
// useTourDataInfinites.ts (핵심 구현)
const useTourDataInfinites = (
  selectedArea: string,
  numOfRows: number,
  category: string,
  initialData?: AreaItem[]
) => {
  return useInfiniteQuery<AreaItem[], Error>({
    queryKey: ["tourList", selectedArea, category],
    queryFn: ({ pageParam = 1 }) =>
      getTourListApi(selectedArea, numOfRows, pageParam as number, category),
    initialPageParam: 1,
    // 다음 페이지가 있는지 확인
    getNextPageParam: (lastPage, allPages) => {
      return lastPage.length < numOfRows ? undefined : allPages.length + 1;
    },
    // 필요시 초기 데이터 제공
    initialData: initialData
      ? {
          pages: [initialData],
          pageParams: [1],
        }
      : undefined,
    staleTime: 1000 * 60 * 15, // 15분
    gcTime: 1000 * 60 * 30, // 30분
  });
};
```

- `getNextPageParam`을 통해 다음 페이지 여부 판단
- 받아온 데이터가 `numOfRows`보다 적으면 더 이상 데이터가 없다고 판단
- 캐싱으로 페이지를 이동했다 돌아와도 API를 다시 호출하지 않음

<video width="100%" controls>
  <source src="https://raw.githubusercontent.com/kimdohoon2/kimdohoon2.github.io/refs/heads/master/_video/무한스크롤1.mp4" type="video/mp4">
  브라우저가 video 태그를 지원하지 않습니다.
</video>

위 영상에서 확인할 수 있듯이, 페이지를 떠났다가 다시 돌아와도 캐시된 데이터를 활용하여 추가 API 호출 없이 이전 상태를 유지합니다.

#### 🔍 Intersection Observer로 스크롤 감지

무한스크롤의 핵심은 스크롤 위치를 감지하는 것입니다. `react-intersection-observer` 라이브러리를 사용해 이를 부드럽게 구현했습니다:

```tsx
// MoreContents.tsx (핵심 부분)
// Intersection Observer 설정
const { ref, inView } = useInView({
  threshold: 0.5, // 요소가 50% 뷰포트에 들어왔을 때 트리거
});

// debounce로 API 호출 최적화
const fetchMoreData = useMemo(
  () =>
    debounce(() => {
      if (
        inView &&
        hasNextPage &&
        moreData.pages.flat().length < MAX_ITEMS &&
        !isFetchingRef.current
      ) {
        isFetchingRef.current = true; // 호출 중 상태 설정
        fetchNextPage().finally(() => {
          isFetchingRef.current = false; // 호출 완료 후 상태 해제
        });
      }
    }, 300), // 300ms 디바운스
  [inView, hasNextPage, fetchNextPage, moreData]
);

// 스크롤 감지 시 다음 페이지 데이터 로드
useEffect(() => {
  if (inView) {
    fetchMoreData();
  }
  return () => {
    fetchMoreData.cancel(); // 언마운트 시 정리
  };
}, [inView, fetchMoreData]);
```

이 구현의 특징:

- `threshold: 0.5`로 요소가 화면의 50% 이상 보일 때만 로드
- `debounce`로 스크롤 이벤트 최적화
- `isFetchingRef`로 중복 API 호출 방지
- 최대 24개 항목만 로드하여 메모리 사용량 제한

### 🔧 성능 최적화 전략과 결과

#### 초기 페이지 로딩 속도 개선

- **초기 데이터 제한**: 각 카테고리별로 8개 항목만 로드하여 초기 로딩 속도 20% 개선
- **지연 로딩**: 사용자가 필요로 할 때만 추가 데이터 로드
- **이미지 최적화**: next/image 컴포넌트로 이미지 최적화

#### API 호출 최적화

- **캐싱 전략**: staleTime, gcTime 설정으로 불필요한 API 호출 50% 감소
- **debounce** 적용: 스크롤 이벤트에 300ms debounce 적용하여 과도한 API 호출 방지
- **조건부 호출**: 필요한 상황에서만 API 호출하도록 다중 조건 설정

#### 사용자 경험 개선

- **스켈레톤 UI**: 데이터 로딩 중 스켈레톤 UI로 사용자 경험 향상
- **최대 항목 수 제한**: 메모리 사용량 최적화 및 브라우저 성능 유지
- **키워드 하이라이트**: 검색 결과에서 입력 키워드를 시각적으로 강조

### 🎯 배운 점

이번 프로젝트를 통해 사용자 경험과 성능 최적화의 균형을 맞추는 법을 배웠다.

1. **사용자 중심 설계**:

   - 단순 기능 구현이 아닌 사용자가 정보를 어떻게 소비하는지 고려한 설계가 중요
   - 기술적 효율성과 사용자 편의성 사이의 균형 유지

2. **성능 최적화**:

   - 초기 로딩 속도, API 호출 최소화, 메모리 사용량 등 다양한 측면 고려
   - React Query의 캐싱 기능이 프론트엔드 성능 향상에 큰 도움

3. **기술적 선택**:
   - 상황에 맞는 적절한 UI 패턴 선택(페이지네이션 vs 무한스크롤)
   - 라이브러리(React Query, Intersection Observer)를 활용한 효율적 구현

앞으로도 단순한 기능 구현이 아니라, 사용자 중심의 개발을 고민하며 성장하는 개발자가 되고 싶다.
